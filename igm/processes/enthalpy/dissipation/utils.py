#!/usr/bin/env python3

# Copyright (C) 2021-2025 IGM authors
# Published under the GNU GPL (Version 3), check at the LICENSE file

import tensorflow as tf
from omegaconf import DictConfig

from igm.common import State
from igm.utils.grad.grad import grad_xy, pad_x, pad_y, pad_z


def compute_strain_heat(cfg: DictConfig, state: State) -> tf.Tensor:
    """
    Compute the volumetric strain heating rate field.

    Calculates viscous dissipation from velocity gradients and the Arrhenius
    factor using Glen's flow law.

    Returns:
        Volumetric strain heating rate (W m^-3).
    """
    cfg_physics = cfg.processes.iceflow.physics

    n = cfg_physics.exp_glen
    h_min = cfg_physics.thr_ice_thk

    dzeta = state.iceflow.vertical_discr.enthalpy.dzeta
    V_U_to_E = state.iceflow.vertical_discr.enthalpy.V_U_to_E
    dz = dzeta * state.thk[None, ...]

    return compute_strain_heat_tf(
        state.U,
        state.V,
        V_U_to_E,
        state.arrhenius,
        state.dx,
        dz,
        n,
        h_min,
    )


# TODO: correct for coordinate-following coordinates?


@tf.function
def compute_strain_heat_tf(
    U: tf.Tensor,
    V: tf.Tensor,
    V_U_to_E: tf.Tensor,
    arrhenius: tf.Tensor,
    dx: tf.Tensor,
    dz: tf.Tensor,
    n: tf.Tensor,
    h_min: tf.Tensor,
    mode_pad_xy: str = "symmetric",
    mode_pad_z: str = "extrapolate",
) -> tf.Tensor:
    """
    TensorFlow function to compute volumetric strain heating.

    Args:
        U: Horizontal velocity in x-direction (m yr^-1).
        V: Horizontal velocity in y-direction (m yr^-1).
        V_U_to_E: Map velocity DOFs to values at enthalpy nodes (Ndof_E, Ndof_U).
        arrhenius: Arrhenius factor field (MPa^-n yr^-1).
        dx: Horizontal grid spacing (m).
        dz: Vertical grid spacing field (m).
        n: Glen's flow law exponent (-).
        h_min: Minimum ice thickness threshold (m).
        mode_pad_xy: Padding mode for horizontal boundaries.
        mode_pad_z: Padding mode for vertical boundaries.

    Returns:
        Volumetric strain heating rate (W m^-3).
    """
    spy = 31556926.0

    U_si = tf.einsum("ij,jkl->ikl", V_U_to_E, U) / spy
    V_si = tf.einsum("ij,jkl->ikl", V_U_to_E, V) / spy

    # Pad velocities in x, y, z directions
    Ui = pad_x(U_si, mode=mode_pad_xy)
    Uj = pad_y(U_si, mode=mode_pad_xy)
    Uk = pad_z(U_si, mode=mode_pad_z)

    Vi = pad_x(V_si, mode=mode_pad_xy)
    Vj = pad_y(V_si, mode=mode_pad_xy)
    Vk = pad_z(V_si, mode=mode_pad_z)

    dz_padded = pad_z(dz, mode="symmetric")
    DZ2 = dz_padded[:-1, :, :] + dz_padded[1:, :, :]

    # Compute strain rate components
    Exx = (Ui[:, :, 2:] - Ui[:, :, :-2]) / (2 * dx)
    Eyy = (Vj[:, 2:, :] - Vj[:, :-2, :]) / (2 * dx)
    Ezz = -Exx - Eyy

    Exy = 0.5 * (
        (Vi[:, :, 2:] - Vi[:, :, :-2]) / (2 * dx)
        + (Uj[:, 2:, :] - Uj[:, :-2, :]) / (2 * dx)
    )

    # Vertical shear strain rates
    Exz = 0.5 * (Uk[2:, :, :] - Uk[:-2, :, :]) / tf.maximum(DZ2, h_min)
    Eyz = 0.5 * (Vk[2:, :, :] - Vk[:-2, :, :]) / tf.maximum(DZ2, h_min)

    # Effective strain rate
    strainrate = tf.sqrt(
        0.5 * (Exx**2 + Eyy**2 + Ezz**2 + 2 * (Exy**2 + Exz**2 + Eyz**2))
    )

    # Convert arrhenius units: MPa⁻³ y⁻¹ to Pa⁻³ s⁻¹
    unit_conversion = 1e18 * spy

    dim_arrhenius = arrhenius.ndim

    arrhenius_expanded = (
        tf.expand_dims(arrhenius, axis=0) if dim_arrhenius == 2 else arrhenius
    )

    return (
        2.0
        * (arrhenius_expanded / unit_conversion) ** (-1.0 / n)
        * strainrate ** (1.0 + 1.0 / n)
    )


def compute_friction_heat(cfg: DictConfig, state: State) -> tf.Tensor:
    """
    Compute the areal frictional heating rate at the bed.

    Calculates heat generated by basal sliding using the Weertman sliding law
    and the sliding coefficient.

    Returns:
        Areal frictional heating rate (W m^-2).
    """
    cfg_physics = cfg.processes.iceflow.physics
    m = cfg_physics.sliding.weertman.exponent

    return compute_friction_heat_tf(
        state.U,
        state.V,
        state.slidingco,
        state.topg,
        state.dX,
        m,
    )


@tf.function
def compute_friction_heat_tf(
    U: tf.Tensor,
    V: tf.Tensor,
    C: tf.Tensor,
    b: tf.Tensor,
    dx: tf.Tensor,
    m: tf.Tensor,
) -> tf.Tensor:
    """
    TensorFlow function to compute basal frictional heating.

    Args:
        U: Horizontal velocity in x-direction (m yr^-1).
        V: Horizontal velocity in y-direction (m yr^-1).
        C: Sliding coefficient field (MPa m^-1/m yr^1/m).
        b: Bed elevation field (m).
        dx: Horizontal grid spacing (m).
        m: Weertman sliding law exponent (-).

    Returns:
        Areal frictional heating rate (W m^-2).
    """
    spy = 31556926.0

    U_si = U / spy
    V_si = V / spy

    # Bed slope
    dbdx, dbdy = grad_xy(b, dx, dx, False, "extrapolate")

    # Vertical velocity component at base
    wvelbase = U_si[0] * dbdx + V_si[0] * dbdy

    # Total basal velocity
    ub = tf.sqrt(U_si[0] ** 2 + V_si[0] ** 2 + wvelbase**2)

    # Friction heating: τ·u
    # Unit conversion: MPa·m⁻¹/ⁿ·y¹/ⁿ → Pa·m/s
    return C * ub ** (1.0 / m + 1.0) * 1e6 * spy ** (1.0 / m)
