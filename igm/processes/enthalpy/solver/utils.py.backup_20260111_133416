#!/usr/bin/env python3

# Copyright (C) 2021-2025 IGM authors
# Published under the GNU GPL (Version 3), check at the LICENSE file

import tensorflow as tf

from typing import Tuple

from omegaconf import DictConfig

from igm.common import State


@tf.function
def drainageFunc(
    omega: tf.Tensor,
    threshold_1: float,
    threshold_2: float,
    threshold_3: float,
) -> tf.Tensor:
    """
    Compute drainage rate as function of water content.

    Following Greve (1997) and Aschwanden et al. (2012).

    Args:
        omega: Water content [dimensionless]
        threshold_1: First drainage threshold
        threshold_2: Second drainage threshold
        threshold_3: Third drainage threshold

    Returns:
        Drainage rate [y⁻¹]
    """
    return tf.where(
        omega <= threshold_1,
        0.0,
        tf.where(
            omega <= threshold_2,
            0.5 * omega - 0.005,
            tf.where(
                omega <= threshold_3,
                4.5 * omega - 0.085,
                0.05,
            ),
        ),
    )


@tf.function
def solve_tridiagonal_system(
    L: tf.Tensor,
    M: tf.Tensor,
    U: tf.Tensor,
    R: tf.Tensor,
) -> tf.Tensor:
    """
    Solve tridiagonal system using Thomas Algorithm (TDMA).

    Args:
        L: Lower diagonal [nz-1, ny, nx]
        M: Main diagonal [nz, ny, nx]
        U: Upper diagonal [nz-1, ny, nx]
        R: Right-hand side [nz, ny, nx]

    Returns:
        Solution [nz, ny, nx]
    """
    nz = tf.shape(M)[0]

    w = tf.TensorArray(dtype=tf.float32, size=nz - 1)
    g = tf.TensorArray(dtype=tf.float32, size=nz)
    p = tf.TensorArray(dtype=tf.float32, size=nz)

    # Forward sweep
    w = w.write(0, U[0] / M[0])
    g = g.write(0, R[0] / M[0])

    for i in tf.range(1, nz - 1):
        w = w.write(i, U[i] / (M[i] - L[i - 1] * w.read(i - 1)))

    for i in tf.range(1, nz):
        g = g.write(
            i, (R[i] - L[i - 1] * g.read(i - 1)) / (M[i] - L[i - 1] * w.read(i - 1))
        )

    # Backward substitution
    p = p.write(nz - 1, g.read(nz - 1))

    for i in tf.range(nz - 2, -1, -1):
        p = p.write(i, g.read(i) - w.read(i) * p.read(i + 1))

    return p.stack()


@tf.function
def assemble_enthalpy_system(
    E: tf.Tensor,
    dt: tf.Tensor,
    dz: tf.Tensor,
    w: tf.Tensor,
    K: tf.Tensor,
    f: tf.Tensor,
    BCB: tf.Tensor,
    VB: tf.Tensor,
    VS: tf.Tensor,
) -> Tuple[tf.Tensor, tf.Tensor, tf.Tensor, tf.Tensor]:
    """
    Assemble finite difference system for enthalpy equation.

    Solves: dE/dt + w·dE/dz = K·d²E/dz² + f

    Args:
        E: Current enthalpy [J/kg]
        dt: Time step [s]
        dz: Layer thickness [m]
        w: Vertical velocity [m/s]
        K: Thermal diffusivity [m²/s]
        f: Source term [W/kg]
        BCB: Bottom BC flag (1=Neumann, 0=Dirichlet)
        VB: Bottom BC value
        VS: Surface BC value

    Returns:
        Tuple of (L, M, U, R) - tridiagonal system components
    """
    nz, ny, nx = E.shape
    s = dt * K / (dz * dz)  # Diffusion coefficient

    # Initialize system
    L = tf.zeros((nz - 1, ny, nx))
    M = tf.ones((nz, ny, nx))
    U = tf.zeros((nz - 1, ny, nx))
    R = E + dt * f

    # Assembly: diffusion terms
    M = M + tf.concat([s, tf.zeros((1, ny, nx))], axis=0)
    M = M + tf.concat([tf.zeros((1, ny, nx)), s], axis=0)
    L = L - s
    U = U - s

    # Bottom boundary condition
    M = tf.concat(
        [tf.where(BCB == 1, -tf.ones_like(BCB), tf.ones_like(BCB))[None, :, :], M[1:]],
        axis=0,
    )
    U = tf.concat(
        [tf.where(BCB == 1, tf.ones_like(BCB), tf.zeros_like(BCB))[None, :, :], U[1:]],
        axis=0,
    )
    R = tf.concat([tf.where(BCB == 1, VB * dz[0], VB)[None, :, :], R[1:]], axis=0)

    # Surface boundary condition
    M = tf.concat([M[:-1], tf.ones_like(BCB)[None, :, :]], axis=0)
    L = tf.concat([L[:-1], tf.zeros_like(BCB)[None, :, :]], axis=0)
    R = tf.concat([R[:-1], VS[None, :, :]], axis=0)

    # Upwind advection (implicit)
    wdivdz = dt * (w[1:] + w[:-1]) / (2.0 * dz)
    L = tf.concat([L[:-1] + tf.where(w[1:-1] > 0, -wdivdz[:-1], 0), L[-1:]], axis=0)
    M = tf.concat(
        [M[:1], M[1:-1] + tf.where(w[1:-1] > 0, wdivdz[:-1], -wdivdz[1:]), M[-1:]],
        axis=0,
    )
    U = tf.concat([U[:1], U[1:] + tf.where(w[1:-1] <= 0, wdivdz[1:], 0)], axis=0)

    return L, M, U, R


def solve_enthalpy_equation(
    cfg: DictConfig,
    state: State,
    E: tf.Tensor,
    E_pmp: tf.Tensor,
    dt: tf.Tensor,
    dz: tf.Tensor,
    E_s: tf.Tensor,
    basal_heat_flux: tf.Tensor,
    strain_heat: tf.Tensor,
    frictional_heat: tf.Tensor,
    h_water_till: tf.Tensor,
) -> Tuple[tf.Tensor, tf.Tensor]:
    """
    Solve enthalpy equation and compute basal melt rate.

    Args:
        cfg: Configuration object
        state: State object (for U, V, dx)
        E: Current enthalpy [J/kg]
        E_pmp: Pressure melting point enthalpy [J/kg]
        dt: Time step [s]
        dz: Layer thickness [m]
        Wc: Corrected vertical velocity [m/s]
        E_s: Surface enthalpy [J/kg]
        basal_heat_flux: Basal heat flux [W/m²]
        strain_heat: Strain heating rate [W/m³]
        frictional_heat: Friction heating rate [W/m²]
        h_water_till: Till water content [m]

    Returns:
        Tuple of (E [J/kg], basal_melt_rate [m/y])
    """
    spy = 31556926.0

    Wc = _compute_corrected_vertical_velocity(state)

    # Horizontal advection (explicit)
    E = E - dt * compute_upwind_advection(
        state.U / spy,
        state.V / spy,
        E,
        state.dx,
    )

    # Solve vertical diffusion-advection (implicit)
    E, basal_melt_rate = _solve_vertical_enthalpy(
        cfg,
        E,
        E_pmp,
        dt,
        dz,
        Wc,
        E_s,
        basal_heat_flux,
        strain_heat,
        frictional_heat,
        h_water_till,
    )

    basal_melt_rate = tf.clip_by_value(basal_melt_rate, 0.0, 1e10)

    return E, basal_melt_rate


def _compute_corrected_vertical_velocity(state: State) -> tf.Tensor:
    """Compute vertical velocity corrected for melting rate."""
    if hasattr(state, "W"):
        return state.W - tf.expand_dims(state.basal_melt_rate, axis=0)
    else:
        return tf.zeros_like(state.U) - tf.expand_dims(state.basal_melt_rate, axis=0)


def _solve_vertical_enthalpy(
    cfg: DictConfig,
    E: tf.Tensor,
    E_pmp: tf.Tensor,
    dt: tf.Tensor,
    dz: tf.Tensor,
    w: tf.Tensor,
    E_s: tf.Tensor,
    basal_heat_flux: tf.Tensor,
    strain_heat: tf.Tensor,
    frictional_heat: tf.Tensor,
    h_water_till: tf.Tensor,
) -> Tuple[tf.Tensor, tf.Tensor]:
    """Solve vertical enthalpy equation with appropriate boundary conditions."""

    spy = 31556926.0

    cfg_thermal = cfg.processes.enthalpy.thermal
    cfg_drainage = cfg.processes.enthalpy.drainage
    cfg_physics = cfg.processes.iceflow.physics

    nz, ny, nx = E.shape

    # Material properties

    ice_density = cfg_physics.ice_density
    h_min = cfg_physics.thr_ice_thk

    k_ice = cfg_thermal.k_ice
    c_ice = cfg_thermal.c_ice
    L_ice = cfg_thermal.L_ice
    T_ref = cfg_thermal.T_ref
    T_min = cfg_thermal.T_min
    K_ratio = cfg_thermal.K_ratio

    water_density = cfg_drainage.water_density
    drain_ice_column = cfg_drainage.drain_ice_column
    omega_target = cfg_drainage.omega_target
    omega_threshold_1 = cfg_drainage.omega_threshold_1
    omega_threshold_2 = cfg_drainage.omega_threshold_2
    omega_threshold_3 = cfg_drainage.omega_threshold_3

    # Thermal diffusivity
    PKc = k_ice / (ice_density * c_ice)  # [m²/s]
    f = strain_heat / ice_density  # [W/kg]

    # Enhanced diffusivity in temperate ice
    K = PKc * tf.ones_like(dz)
    K = tf.where(
        (E[:-1] + E[1:]) / 2.0 >= (E_pmp[:-1] + E_pmp[1:]) / 2.0, K * K_ratio, K
    )

    # Boundary conditions
    VS = E_s

    COLD_BASE = (E[0] < E_pmp[0]) | (h_water_till <= 0)
    DRY_ICE = h_water_till <= 0
    COLD_ICE = E[1] < E_pmp[1]

    # BC flags: 1=Neumann, 0=Dirichlet
    BCB = tf.where(
        COLD_BASE,
        tf.where(DRY_ICE, tf.ones((ny, nx)), tf.zeros((ny, nx))),
        tf.where(COLD_ICE, tf.zeros((ny, nx)), tf.ones((ny, nx))),
    )

    VB = tf.where(
        COLD_BASE,
        tf.where(
            DRY_ICE, -(c_ice / k_ice) * (basal_heat_flux + frictional_heat), E_pmp[0]
        ),
        tf.where(COLD_ICE, E_pmp[0], 0.0),
    )

    # Assemble and solve system
    L, M, U, R = assemble_enthalpy_system(
        E, dt, tf.maximum(dz, h_min), w, K, f, BCB, VB, VS
    )

    E = solve_tridiagonal_system(L, M, U, R)

    # Enforce bounds
    Emin = c_ice * (T_min - T_ref)
    E = tf.maximum(E, Emin)

    Emax = E_pmp + L_ice  # omega = 1
    E = tf.minimum(E, Emax)

    # Compute basal heat flux
    flux = tf.where(
        E[1] < E_pmp[1],
        -(k_ice / c_ice) * (E[1] - E[0]) / tf.maximum(dz[0], h_min),
        -K_ratio * (k_ice / c_ice) * (E[1] - E[0]) / tf.maximum(dz[0], h_min),
    )

    # Basal melt rate [m/y]
    basal_melt_rate = tf.where(
        (E[0] < E_pmp[0]) & (h_water_till <= 0),
        tf.zeros((ny, nx)),
        spy * (basal_heat_flux + frictional_heat - flux) / (water_density * L_ice),
    )

    # Drainage along ice column
    if (dt > 0) and drain_ice_column:
        E, basal_melt_rate = _apply_drainage(
            E,
            E_pmp,
            dt,
            dz,
            basal_melt_rate,
            L_ice,
            ice_density,
            water_density,
            spy,
            omega_target,
            omega_threshold_1,
            omega_threshold_2,
            omega_threshold_3,
        )

    return E, basal_melt_rate


@tf.function
def _apply_drainage(
    E: tf.Tensor,
    E_pmp: tf.Tensor,
    dt: tf.Tensor,
    dz: tf.Tensor,
    basal_melt_rate: tf.Tensor,
    L_ice: float,
    ice_density: float,
    water_density: float,
    spy: float,
    target_water_fraction: float,
    threshold_1: float,
    threshold_2: float,
    threshold_3: float,
) -> Tuple[tf.Tensor, tf.Tensor]:
    """Apply water drainage through ice column."""
    # Cell-centered layer thickness
    DZ = tf.concat([dz[0:1], dz[:-1] + dz[1:], dz[-1:]], axis=0) / 2.0

    # Water content
    omega = tf.maximum((E - E_pmp) / L_ice, 0.0)

    # Identify cells to drain
    CD = omega > target_water_fraction

    # Drainage fraction
    fraction_drained = (
        drainageFunc(omega, threshold_1, threshold_2, threshold_3) * dt / spy
    )
    fraction_drained = tf.minimum(fraction_drained, omega - target_water_fraction)

    # Drained water thickness
    H_drained = tf.where(CD, fraction_drained * DZ, 0.0)  # [m]

    # Update enthalpy
    E = tf.where(CD, E - fraction_drained * L_ice, E)

    # Total drained water
    H_total_drained = tf.reduce_sum(H_drained, axis=0)  # [m]

    # Add to basal melt rate
    basal_melt_rate = (
        basal_melt_rate + (spy / dt) * (ice_density / water_density) * H_total_drained
    )

    return E, basal_melt_rate


@tf.function
def compute_upwind_advection(
    U: tf.Tensor,
    V: tf.Tensor,
    E: tf.Tensor,
    dx: float,
) -> tf.Tensor:
    """
    Compute horizontal advection using upwind scheme.

    Computes: U·∂E/∂x + V·∂E/∂y

    Args:
        U: X-velocity [m/s]
        V: Y-velocity [m/s]
        E: Field to advect (e.g., enthalpy) [any units]
        dx: Horizontal grid spacing [m]

    Returns:
        Advection rate [E·s⁻¹]
    """
    # Extend E with symmetric boundary conditions
    Ex = tf.pad(E, [[0, 0], [0, 0], [1, 1]], "SYMMETRIC")  # shape: (nz, ny, nx+2)
    Ey = tf.pad(E, [[0, 0], [1, 1], [0, 0]], "SYMMETRIC")  # shape: (nz, ny+2, nx)

    # Upwind differences in x-direction
    Rx = U * tf.where(
        U > 0,
        (Ex[:, :, 1:-1] - Ex[:, :, :-2]) / dx,  # Forward difference
        (Ex[:, :, 2:] - Ex[:, :, 1:-1]) / dx,  # Backward difference
    )

    # Upwind differences in y-direction
    Ry = V * tf.where(
        V > 0,
        (Ey[:, 1:-1, :] - Ey[:, :-2, :]) / dx,  # Forward difference
        (Ey[:, 2:, :] - Ey[:, 1:-1, :]) / dx,  # Backward difference
    )

    return Rx + Ry
